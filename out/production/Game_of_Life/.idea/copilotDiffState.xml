<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/game.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game.java" />
              <option name="originalContent" value="import java.awt.*;&#10;import java.awt.event.*;&#10;import javax.swing.*;&#10;&#10;public class game extends JFrame {&#10;    boolean[][] boxes;&#10;    boolean[][] nextBoxes;&#10;    static final int GRID_SIZE = 100;&#10;    static final int CELL_SIZE = 8;&#10;    boolean drawValue = true;&#10;    Timer timer;&#10;    GridPanel gridPanel;&#10;    JSlider speedSlider;&#10;    public Color cellColor = Color.WHITE;&#10;    &#10;    public game() {&#10;        boxes = new boolean[GRID_SIZE][GRID_SIZE];&#10;        nextBoxes = new boolean[GRID_SIZE][GRID_SIZE];&#10;        &#10;        setTitle(&quot;Game of Life&quot;);&#10;        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        setLayout(new BorderLayout());&#10;        &#10;        gridPanel = new GridPanel();&#10;        &#10;        JPanel controls = new JPanel();&#10;        JButton play = new JButton(&quot;Play&quot;);&#10;        JButton pause = new JButton(&quot;Pause&quot;);&#10;        JButton reset = new JButton(&quot;Reset&quot;);&#10;        &#10;        speedSlider = new JSlider(10, 500, 100);&#10;        speedSlider.setInverted(true);&#10;        speedSlider.addChangeListener(e -&gt; {&#10;            if (timer != null) timer.setDelay(speedSlider.getValue());&#10;        });&#10;        &#10;        play.addActionListener(e -&gt; play());&#10;        pause.addActionListener(e -&gt; pause());&#10;        reset.addActionListener(e -&gt; reset());&#10;        &#10;        controls.add(play);&#10;        controls.add(pause);&#10;        controls.add(reset);&#10;        controls.add(new JLabel(&quot;Speed:&quot;));&#10;        controls.add(speedSlider);&#10;        &#10;        add(gridPanel, BorderLayout.CENTER);&#10;        add(controls, BorderLayout.SOUTH);&#10;        &#10;        pack();&#10;        setLocationRelativeTo(null);&#10;        setVisible(true);&#10;    }&#10;    &#10;    // Custom panel for drawing the grid&#10;    class GridPanel extends JPanel {&#10;        public GridPanel() {&#10;            setPreferredSize(new Dimension(GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE));&#10;            setBackground(Color.BLACK);&#10;            &#10;            addMouseListener(new MouseAdapter() {&#10;                @Override&#10;                public void mousePressed(MouseEvent e) {&#10;                    int col = e.getX() / CELL_SIZE;&#10;                    int row = e.getY() / CELL_SIZE;&#10;                    if (row &gt;= 0 &amp;&amp; row &lt; GRID_SIZE &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; GRID_SIZE) {&#10;                        boxes[row][col] = !boxes[row][col];&#10;                        drawValue = boxes[row][col];&#10;                        repaint();&#10;                    }&#10;                }&#10;            });&#10;            &#10;            addMouseMotionListener(new MouseAdapter() {&#10;                @Override&#10;                public void mouseDragged(MouseEvent e) {&#10;                    int col = e.getX() / CELL_SIZE;&#10;                    int row = e.getY() / CELL_SIZE;&#10;                    if (row &gt;= 0 &amp;&amp; row &lt; GRID_SIZE &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; GRID_SIZE) {&#10;                        boxes[row][col] = drawValue;&#10;                        repaint();&#10;                    }&#10;                }&#10;            });&#10;        }&#10;        &#10;        @Override&#10;        protected void paintComponent(Graphics g) {&#10;            super.paintComponent(g);&#10;            g.setColor(Color.WHITE);&#10;            &#10;            // Only draw alive cells&#10;            for (int i = 0; i &lt; GRID_SIZE; i++) {&#10;                for (int j = 0; j &lt; GRID_SIZE; j++) {&#10;                    if (boxes[i][j]) {&#10;                        g.fillRect(j * CELL_SIZE, i * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    void play() {&#10;        if (timer == null) timer = new Timer(speedSlider.getValue(), e -&gt; updateGeneration());&#10;        timer.start();&#10;    }&#10;    &#10;    void pause() {&#10;        if (timer != null) timer.stop();&#10;    }&#10;    &#10;    void updateGeneration() {&#10;        for (int i = 0; i &lt; GRID_SIZE; i++) {&#10;            for (int j = 0; j &lt; GRID_SIZE; j++) {&#10;                int neighbors = countAliveNeighbors(i, j);&#10;                nextBoxes[i][j] = boxes[i][j] ? (neighbors == 2 || neighbors == 3) : (neighbors == 3);&#10;            }&#10;        }&#10;        boolean[][] temp = boxes;&#10;        boxes = nextBoxes;&#10;        nextBoxes = temp;&#10;        gridPanel.repaint();&#10;    }&#10;    &#10;    void reset() {&#10;        pause();&#10;        boxes = new boolean[GRID_SIZE][GRID_SIZE];&#10;        nextBoxes = new boolean[GRID_SIZE][GRID_SIZE];&#10;        gridPanel.repaint();&#10;    }&#10;    &#10;    int countAliveNeighbors(int row, int col) {&#10;        int count = 0;&#10;        for (int dr = -1; dr &lt;= 1; dr++) {&#10;            for (int dc = -1; dc &lt;= 1; dc++) {&#10;                if (dr == 0 &amp;&amp; dc == 0) continue;&#10;                int r = row + dr;&#10;                int c = col + dc;&#10;                if (r &gt;= 0 &amp;&amp; r &lt; GRID_SIZE &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; GRID_SIZE &amp;&amp; boxes[r][c]) {&#10;                    count++;&#10;                }&#10;            }&#10;        }&#10;        return count;&#10;    }&#10;    &#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; new game());&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import java.awt.*;&#10;import java.awt.event.*;&#10;import javax.swing.*;&#10;import javax.swing.event.*;&#10;&#10;public class game extends JFrame {&#10;    boolean[][] boxes;&#10;    boolean[][] nextBoxes;&#10;    static final int GRID_SIZE = 100;&#10;    static final int CELL_SIZE = 8;&#10;    boolean drawValue = true;&#10;    Timer timer;&#10;    GridPanel gridPanel;&#10;    JSlider speedSlider;&#10;    public Color cellColor = Color.WHITE;&#10;    &#10;    public game() {&#10;        boxes = new boolean[GRID_SIZE][GRID_SIZE];&#10;        nextBoxes = new boolean[GRID_SIZE][GRID_SIZE];&#10;        &#10;        setTitle(&quot;Game of Life&quot;);&#10;        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        setLayout(new BorderLayout());&#10;        &#10;        gridPanel = new GridPanel();&#10;        &#10;        JPanel controls = new JPanel();&#10;        JButton play = new JButton(&quot;Play&quot;);&#10;        JButton pause = new JButton(&quot;Pause&quot;);&#10;        JButton reset = new JButton(&quot;Reset&quot;);&#10;        &#10;        speedSlider = new JSlider(10, 500, 100);&#10;        speedSlider.setInverted(true);&#10;        speedSlider.addChangeListener(e -&gt; {&#10;            if (timer != null) timer.setDelay(speedSlider.getValue());&#10;        });&#10;        &#10;        play.addActionListener(e -&gt; play());&#10;        pause.addActionListener(e -&gt; pause());&#10;        reset.addActionListener(e -&gt; reset());&#10;        &#10;        controls.add(play);&#10;        controls.add(pause);&#10;        controls.add(reset);&#10;        controls.add(new JLabel(&quot;Speed:&quot;));&#10;        controls.add(speedSlider);&#10;        &#10;        add(gridPanel, BorderLayout.CENTER);&#10;        add(controls, BorderLayout.SOUTH);&#10;&#10;        // set up the menu bar (color palette etc.)&#10;        setupMenuBar();&#10;        &#10;        pack();&#10;        setLocationRelativeTo(null);&#10;        setVisible(true);&#10;    }&#10;    &#10;    // Custom panel for drawing the grid&#10;    class GridPanel extends JPanel {&#10;        public GridPanel() {&#10;            setPreferredSize(new Dimension(GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE));&#10;            setBackground(Color.BLACK);&#10;            &#10;            addMouseListener(new MouseAdapter() {&#10;                @Override&#10;                public void mousePressed(MouseEvent e) {&#10;                    int col = e.getX() / CELL_SIZE;&#10;                    int row = e.getY() / CELL_SIZE;&#10;                    if (row &gt;= 0 &amp;&amp; row &lt; GRID_SIZE &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; GRID_SIZE) {&#10;                        boxes[row][col] = !boxes[row][col];&#10;                        drawValue = boxes[row][col];&#10;                        repaint();&#10;                    }&#10;                }&#10;            });&#10;            &#10;            addMouseMotionListener(new MouseAdapter() {&#10;                @Override&#10;                public void mouseDragged(MouseEvent e) {&#10;                    int col = e.getX() / CELL_SIZE;&#10;                    int row = e.getY() / CELL_SIZE;&#10;                    if (row &gt;= 0 &amp;&amp; row &lt; GRID_SIZE &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; GRID_SIZE) {&#10;                        boxes[row][col] = drawValue;&#10;                        repaint();&#10;                    }&#10;                }&#10;            });&#10;        }&#10;        &#10;        @Override&#10;        protected void paintComponent(Graphics g) {&#10;            super.paintComponent(g);&#10;            // use the chosen cell color (may change at runtime via the menu)&#10;            g.setColor(cellColor);&#10;            &#10;            // Only draw alive cells&#10;            for (int i = 0; i &lt; GRID_SIZE; i++) {&#10;                for (int j = 0; j &lt; GRID_SIZE; j++) {&#10;                    if (boxes[i][j]) {&#10;                        g.fillRect(j * CELL_SIZE, i * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Add a menu bar with a color palette popup. Hovering previews color; click or release selects it.&#10;    private void setupMenuBar() {&#10;        JMenuBar menuBar = new JMenuBar();&#10;        JMenu optionsMenu = new JMenu(&quot;Options&quot;);&#10;        JMenu colorMenu = new JMenu(&quot;Color&quot;);&#10;&#10;        // Build a small palette&#10;        final Color[] paletteColors = new Color[] {&#10;            Color.WHITE, Color.LIGHT_GRAY, Color.GRAY, Color.DARK_GRAY, Color.BLACK,&#10;            Color.RED, Color.ORANGE, Color.YELLOW, Color.GREEN, Color.MAGENTA,&#10;            Color.CYAN, Color.BLUE, new Color(139,69,19), // brown&#10;            new Color(255,192,203), // pink&#10;            new Color(128,0,128), // purple&#10;            new Color(0,128,128) // teal&#10;        };&#10;&#10;        final JPopupMenu palettePopup = new JPopupMenu();&#10;        JPanel palettePanel = new JPanel(new GridLayout(4, 4, 4, 4));&#10;        palettePanel.setBorder(BorderFactory.createEmptyBorder(6, 6, 6, 6));&#10;        palettePanel.setBackground(Color.WHITE);&#10;&#10;        // Track last hovered color for selection on mouse release&#10;        final Color[] lastHovered = new Color[1];&#10;&#10;        for (Color c : paletteColors) {&#10;            JLabel swatch = new JLabel();&#10;            swatch.setOpaque(true);&#10;            swatch.setBackground(c);&#10;            swatch.setPreferredSize(new Dimension(24, 24));&#10;            swatch.setBorder(BorderFactory.createLineBorder(Color.BLACK));&#10;            swatch.addMouseListener(new MouseAdapter() {&#10;                @Override&#10;                public void mouseEntered(MouseEvent e) {&#10;                    // preview on hover&#10;                    lastHovered[0] = c;&#10;                    cellColor = c;&#10;                    gridPanel.repaint();&#10;                }&#10;&#10;                @Override&#10;                public void mousePressed(MouseEvent e) {&#10;                    // immediate selection on click&#10;                    cellColor = c;&#10;                    gridPanel.repaint();&#10;                    palettePopup.setVisible(false);&#10;                }&#10;&#10;                @Override&#10;                public void mouseReleased(MouseEvent e) {&#10;                    // if the user was dragging and releases over a swatch, pick it&#10;                    if (lastHovered[0] != null) {&#10;                        cellColor = lastHovered[0];&#10;                        gridPanel.repaint();&#10;                        palettePopup.setVisible(false);&#10;                    }&#10;                }&#10;            });&#10;            palettePanel.add(swatch);&#10;        }&#10;&#10;        // If mouse exits the palette without selecting, we keep the preview color (user asked to get the color when dragging over).&#10;        palettePanel.addMouseListener(new MouseAdapter() {&#10;            @Override&#10;            public void mouseExited(MouseEvent e) {&#10;                // do nothing special; keep last preview&#10;            }&#10;        });&#10;&#10;        palettePopup.add(palettePanel);&#10;&#10;        // Show the palette when the Color menu is selected&#10;        colorMenu.addMenuListener(new MenuListener() {&#10;            @Override&#10;            public void menuSelected(MenuEvent e) {&#10;                // show popup just below the Color menu&#10;                // use the menu bar as invoker so coordinates are relative to it&#10;                int x = colorMenu.getX();&#10;                int y = colorMenu.getY() + colorMenu.getHeight();&#10;                palettePopup.show(menuBar, x, y);&#10;            }&#10;&#10;            @Override&#10;            public void menuDeselected(MenuEvent e) {&#10;                palettePopup.setVisible(false);&#10;            }&#10;&#10;            @Override&#10;            public void menuCanceled(MenuEvent e) {&#10;                palettePopup.setVisible(false);&#10;            }&#10;        });&#10;&#10;        optionsMenu.add(colorMenu);&#10;        menuBar.add(optionsMenu);&#10;        setJMenuBar(menuBar);&#10;    }&#10;    &#10;    void play() {&#10;        if (timer == null) timer = new Timer(speedSlider.getValue(), e -&gt; updateGeneration());&#10;        timer.start();&#10;    }&#10;    &#10;    void pause() {&#10;        if (timer != null) timer.stop();&#10;    }&#10;    &#10;    void updateGeneration() {&#10;        for (int i = 0; i &lt; GRID_SIZE; i++) {&#10;            for (int j = 0; j &lt; GRID_SIZE; j++) {&#10;                int neighbors = countAliveNeighbors(i, j);&#10;                nextBoxes[i][j] = boxes[i][j] ? (neighbors == 2 || neighbors == 3) : (neighbors == 3);&#10;            }&#10;        }&#10;        boolean[][] temp = boxes;&#10;        boxes = nextBoxes;&#10;        nextBoxes = temp;&#10;        gridPanel.repaint();&#10;    }&#10;    &#10;    void reset() {&#10;        pause();&#10;        boxes = new boolean[GRID_SIZE][GRID_SIZE];&#10;        nextBoxes = new boolean[GRID_SIZE][GRID_SIZE];&#10;        gridPanel.repaint();&#10;    }&#10;    &#10;    int countAliveNeighbors(int row, int col) {&#10;        int count = 0;&#10;        for (int dr = -1; dr &lt;= 1; dr++) {&#10;            for (int dc = -1; dc &lt;= 1; dc++) {&#10;                if (dr == 0 &amp;&amp; dc == 0) continue;&#10;                int r = row + dr;&#10;                int c = col + dc;&#10;                if (r &gt;= 0 &amp;&amp; r &lt; GRID_SIZE &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; GRID_SIZE &amp;&amp; boxes[r][c]) {&#10;                    count++;&#10;                }&#10;            }&#10;        }&#10;        return count;&#10;    }&#10;    &#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; new game());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>